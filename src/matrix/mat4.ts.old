// /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE. */

// import { glMatrix } from './common';
// import { quat, vec3 } from './mathmatrix';

// export class mat4 extends Float32Array {
//     /**
//  * Creates a new identity mat4
//  *
//  * @returns {mat4} a new 4x4 matrix
//  */
//     public static create(): Float32Array {
//         const out = new Float32Array(16);
//         out[0] = 1;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = 1;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = 1;
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a new mat4 initialized with values from an existing matrix
//      *
//      * @param {mat4} a matrix to clone
//      * @returns {mat4} a new 4x4 matrix
//      */
//     public static clone(a: Float32Array): Float32Array {
//         const out = new Float32Array(16);
//         out[0] = a[0];
//         out[1] = a[1];
//         out[2] = a[2];
//         out[3] = a[3];
//         out[4] = a[4];
//         out[5] = a[5];
//         out[6] = a[6];
//         out[7] = a[7];
//         out[8] = a[8];
//         out[9] = a[9];
//         out[10] = a[10];
//         out[11] = a[11];
//         out[12] = a[12];
//         out[13] = a[13];
//         out[14] = a[14];
//         out[15] = a[15];
//         return out;
//     }

//     /**
//      * Copy the values from one mat4 to another
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the source matrix
//      * @returns {mat4} out
//      */
//     public static copy(out: Float32Array, a: Float32Array): Float32Array {
//         out[0] = a[0];
//         out[1] = a[1];
//         out[2] = a[2];
//         out[3] = a[3];
//         out[4] = a[4];
//         out[5] = a[5];
//         out[6] = a[6];
//         out[7] = a[7];
//         out[8] = a[8];
//         out[9] = a[9];
//         out[10] = a[10];
//         out[11] = a[11];
//         out[12] = a[12];
//         out[13] = a[13];
//         out[14] = a[14];
//         out[15] = a[15];
//         return out;
//     }

//     /**
//      * Create a new mat4 with the given values
//      *
//      * @param {Number} m00 Component in column 0, row 0 position (index 0)
//      * @param {Number} m01 Component in column 0, row 1 position (index 1)
//      * @param {Number} m02 Component in column 0, row 2 position (index 2)
//      * @param {Number} m03 Component in column 0, row 3 position (index 3)
//      * @param {Number} m10 Component in column 1, row 0 position (index 4)
//      * @param {Number} m11 Component in column 1, row 1 position (index 5)
//      * @param {Number} m12 Component in column 1, row 2 position (index 6)
//      * @param {Number} m13 Component in column 1, row 3 position (index 7)
//      * @param {Number} m20 Component in column 2, row 0 position (index 8)
//      * @param {Number} m21 Component in column 2, row 1 position (index 9)
//      * @param {Number} m22 Component in column 2, row 2 position (index 10)
//      * @param {Number} m23 Component in column 2, row 3 position (index 11)
//      * @param {Number} m30 Component in column 3, row 0 position (index 12)
//      * @param {Number} m31 Component in column 3, row 1 position (index 13)
//      * @param {Number} m32 Component in column 3, row 2 position (index 14)
//      * @param {Number} m33 Component in column 3, row 3 position (index 15)
//      * @returns {mat4} A new mat4
//      */
//     public static fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number,
//         m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Float32Array {
//         const out = new Float32Array(16);
//         out[0] = m00;
//         out[1] = m01;
//         out[2] = m02;
//         out[3] = m03;
//         out[4] = m10;
//         out[5] = m11;
//         out[6] = m12;
//         out[7] = m13;
//         out[8] = m20;
//         out[9] = m21;
//         out[10] = m22;
//         out[11] = m23;
//         out[12] = m30;
//         out[13] = m31;
//         out[14] = m32;
//         out[15] = m33;
//         return out;
//     }

//     /**
//      * Set the components of a mat4 to the given values
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {Number} m00 Component in column 0, row 0 position (index 0)
//      * @param {Number} m01 Component in column 0, row 1 position (index 1)
//      * @param {Number} m02 Component in column 0, row 2 position (index 2)
//      * @param {Number} m03 Component in column 0, row 3 position (index 3)
//      * @param {Number} m10 Component in column 1, row 0 position (index 4)
//      * @param {Number} m11 Component in column 1, row 1 position (index 5)
//      * @param {Number} m12 Component in column 1, row 2 position (index 6)
//      * @param {Number} m13 Component in column 1, row 3 position (index 7)
//      * @param {Number} m20 Component in column 2, row 0 position (index 8)
//      * @param {Number} m21 Component in column 2, row 1 position (index 9)
//      * @param {Number} m22 Component in column 2, row 2 position (index 10)
//      * @param {Number} m23 Component in column 2, row 3 position (index 11)
//      * @param {Number} m30 Component in column 3, row 0 position (index 12)
//      * @param {Number} m31 Component in column 3, row 1 position (index 13)
//      * @param {Number} m32 Component in column 3, row 2 position (index 14)
//      * @param {Number} m33 Component in column 3, row 3 position (index 15)
//      * @returns {mat4} out
//      */
//     public static set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33): Float32Array {
//         out[0] = m00;
//         out[1] = m01;
//         out[2] = m02;
//         out[3] = m03;
//         out[4] = m10;
//         out[5] = m11;
//         out[6] = m12;
//         out[7] = m13;
//         out[8] = m20;
//         out[9] = m21;
//         out[10] = m22;
//         out[11] = m23;
//         out[12] = m30;
//         out[13] = m31;
//         out[14] = m32;
//         out[15] = m33;
//         return out;
//     }

//     public static set2(mat, dest) {
//         dest[0] = mat[0];
//         dest[1] = mat[1];
//         dest[2] = mat[2];
//         dest[3] = mat[3];
//         dest[4] = mat[4];
//         dest[5] = mat[5];
//         dest[6] = mat[6];
//         dest[7] = mat[7];
//         dest[8] = mat[8];
//         dest[9] = mat[9];
//         dest[10] = mat[10];
//         dest[11] = mat[11];
//         dest[12] = mat[12];
//         dest[13] = mat[13];
//         dest[14] = mat[14];
//         dest[15] = mat[15];
//         return dest;
//     }

//     /**
//      * Set a mat4 to the identity matrix
//      *
//      * @param {mat4} out the receiving matrix
//      * @returns {mat4} out
//      */
//     public static identity(out: Float32Array): Float32Array {
//         out[0] = 1;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = 1;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = 1;
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Transpose the values of a mat4 not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the source matrix
//      * @returns {mat4} out
//      */
//     public static transpose(out: Float32Array, a: Float32Array): Float32Array {
//         // If we are transposing ourselves we can skip a few steps but have to cache some values
//         if (out === a) {
//             const a01 = a[1];
//             const a02 = a[2];
//             const a03 = a[3];
//             const a12 = a[6];
//             const a13 = a[7];
//             const a23 = a[11];

//             out[1] = a[4];
//             out[2] = a[8];
//             out[3] = a[12];
//             out[4] = a01;
//             out[6] = a[9];
//             out[7] = a[13];
//             out[8] = a02;
//             out[9] = a12;
//             out[11] = a[14];
//             out[12] = a03;
//             out[13] = a13;
//             out[14] = a23;
//         } else {
//             out[0] = a[0];
//             out[1] = a[4];
//             out[2] = a[8];
//             out[3] = a[12];
//             out[4] = a[1];
//             out[5] = a[5];
//             out[6] = a[9];
//             out[7] = a[13];
//             out[8] = a[2];
//             out[9] = a[6];
//             out[10] = a[10];
//             out[11] = a[14];
//             out[12] = a[3];
//             out[13] = a[7];
//             out[14] = a[11];
//             out[15] = a[15];
//         }

//         return out;
//     }


//     /**
//      * Inverts a mat4 not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the source matrix
//      * @returns {mat4} out
//      */
//     public static invert(out: Float32Array, a: Float32Array): Float32Array {
//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];
//         const a30 = a[12];
//         const a31 = a[13];
//         const a32 = a[14];
//         const a33 = a[15];

//         const b00 = a00 * a11 - a01 * a10;
//         const b01 = a00 * a12 - a02 * a10;
//         const b02 = a00 * a13 - a03 * a10;
//         const b03 = a01 * a12 - a02 * a11;
//         const b04 = a01 * a13 - a03 * a11;
//         const b05 = a02 * a13 - a03 * a12;
//         const b06 = a20 * a31 - a21 * a30;
//         const b07 = a20 * a32 - a22 * a30;
//         const b08 = a20 * a33 - a23 * a30;
//         const b09 = a21 * a32 - a22 * a31;
//         const b10 = a21 * a33 - a23 * a31;
//         const b11 = a22 * a33 - a23 * a32;

//         // Calculate the determinant
//         let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

//         if (!det) {
//             return null;
//         }
//         det = 1.0 / det;

//         out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
//         out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
//         out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
//         out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
//         out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
//         out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
//         out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
//         out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
//         out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
//         out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
//         out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
//         out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
//         out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
//         out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
//         out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
//         out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

//         return out;
//     }


//     /**
//      * Calculates the adjugate of a mat4 not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the source matrix
//      * @returns {mat4} out
//      */
//     public static adjoint(out: Float32Array, a: Float32Array): Float32Array {
//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];
//         const a30 = a[12];
//         const a31 = a[13];
//         const a32 = a[14];
//         const a33 = a[15];

//         out[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
//         out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
//         out[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
//         out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
//         out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
//         out[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
//         out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
//         out[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
//         out[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
//         out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
//         out[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
//         out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
//         out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
//         out[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
//         out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
//         out[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
//         return out;
//     }

//     /**
//      * Calculates the determinant of a mat4
//      *
//      * @param {mat4} a the source matrix
//      * @returns {Number} determinant of a
//      */
//     public static determinant(a: Float32Array): number {
//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];
//         const a30 = a[12];
//         const a31 = a[13];
//         const a32 = a[14];
//         const a33 = a[15];

//         const b00 = a00 * a11 - a01 * a10;
//         const b01 = a00 * a12 - a02 * a10;
//         const b02 = a00 * a13 - a03 * a10;
//         const b03 = a01 * a12 - a02 * a11;
//         const b04 = a01 * a13 - a03 * a11;
//         const b05 = a02 * a13 - a03 * a12;
//         const b06 = a20 * a31 - a21 * a30;
//         const b07 = a20 * a32 - a22 * a30;
//         const b08 = a20 * a33 - a23 * a30;
//         const b09 = a21 * a32 - a22 * a31;
//         const b10 = a21 * a33 - a23 * a31;
//         const b11 = a22 * a33 - a23 * a32;

//         // Calculate the determinant
//         return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
//     }


//     /**
//      * Multiplies two mat4's explicitly not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the first operand
//      * @param {mat4} b the second operand
//      * @returns {mat4} out
//      */
//     public static multiply(out: Float32Array, a: Float32Array, b: Float32Array): Float32Array {
//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];
//         const a30 = a[12];
//         const a31 = a[13];
//         const a32 = a[14];
//         const a33 = a[15];

//         // Cache only the current line of the second matrix
//         let b0 = b[0];
//         let b1 = b[1];
//         let b2 = b[2];
//         let b3 = b[3];
//         out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
//         out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
//         out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
//         out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

//         b0 = b[4];
//         b1 = b[5];
//         b2 = b[6];
//         b3 = b[7];
//         out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
//         out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
//         out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
//         out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

//         b0 = b[8];
//         b1 = b[9];
//         b2 = b[10];
//         b3 = b[11];
//         out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
//         out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
//         out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
//         out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

//         b0 = b[12];
//         b1 = b[13];
//         b2 = b[14];
//         b3 = b[15];
//         out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
//         out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
//         out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
//         out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
//         return out;
//     }

//     public static multiplyVec4(mat, vec, dest) {
//         if (!dest) {
//             dest = vec;
//         }

//         const x = vec[0];
//         const y = vec[1];
//         const z = vec[2];
//         const w = vec[3];

//         dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
//         dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
//         dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
//         dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

//         return dest;
//     }


//     /**
//      * Alias for {@link mat4.multiply}
//      * @function
//      */
//     public static mul = mat4.multiply;

//     /**
//      * Translate a mat4 by the given vector not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to translate
//      * @param {vec3} v vector to translate by
//      * @returns {mat4} out
//      */
//     public static translate(out: Float32Array, a: Float32Array, v: vec3 | number[]) {
//         const x = v[0]; const y = v[1]; const z = v[2];
//         let a00;
//         let a01;
//         let a02;
//         let a03;
//         let a10;
//         let a11;
//         let a12;
//         let a13;
//         let a20;
//         let a21;
//         let a22;
//         let a23;

//         if (a === out) {
//             out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
//             out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
//             out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
//             out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
//         } else {
//             a00 = a[0];
//             a01 = a[1];
//             a02 = a[2];
//             a03 = a[3];
//             a10 = a[4];
//             a11 = a[5];
//             a12 = a[6];
//             a13 = a[7];
//             a20 = a[8];
//             a21 = a[9];
//             a22 = a[10];
//             a23 = a[11];

//             out[0] = a00;
//             out[1] = a01;
//             out[2] = a02;
//             out[3] = a03;
//             out[4] = a10;
//             out[5] = a11;
//             out[6] = a12;
//             out[7] = a13;
//             out[8] = a20;
//             out[9] = a21;
//             out[10] = a22;
//             out[11] = a23;

//             out[12] = a00 * x + a10 * y + a20 * z + a[12];
//             out[13] = a01 * x + a11 * y + a21 * z + a[13];
//             out[14] = a02 * x + a12 * y + a22 * z + a[14];
//             out[15] = a03 * x + a13 * y + a23 * z + a[15];
//         }

//         return out;
//     }

//     /**
//      * Scales the mat4 by the dimensions in the given vec3 not using vectorization
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to scale
//      * @param {vec3} v the vec3 to scale the matrix by
//      * @returns {mat4} out
//      **/
//     public static scale(out: Float32Array, a: Float32Array, v: vec3): Float32Array {
//         const x = v[0];
//         const y = v[1];
//         const z = v[2];

//         out[0] = a[0] * x;
//         out[1] = a[1] * x;
//         out[2] = a[2] * x;
//         out[3] = a[3] * x;
//         out[4] = a[4] * y;
//         out[5] = a[5] * y;
//         out[6] = a[6] * y;
//         out[7] = a[7] * y;
//         out[8] = a[8] * z;
//         out[9] = a[9] * z;
//         out[10] = a[10] * z;
//         out[11] = a[11] * z;
//         out[12] = a[12];
//         out[13] = a[13];
//         out[14] = a[14];
//         out[15] = a[15];
//         return out;
//     }


//     /**
//      * Rotates a mat4 by the given angle around the given axis
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to rotate
//      * @param {Number} rad the angle to rotate the matrix by
//      * @param {vec3} axis the axis to rotate around
//      * @returns {mat4} out
//      */
//     public static rotate(out: Float32Array, a: Float32Array, rad: number, axis: vec3 | number[]): Float32Array {
//         let x = axis[0];
//         let y = axis[1];
//         let z = axis[2];
//         let len = Math.sqrt(x * x + y * y + z * z);

//         if (Math.abs(len) < glMatrix.EPSILON) {
//             return null;
//         }

//         len = 1 / len;
//         x *= len;
//         y *= len;
//         z *= len;

//         const s = Math.sin(rad);
//         const c = Math.cos(rad);
//         const t = 1 - c;

//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];

//         // Construct the elements of the rotation matrix
//         const b00 = x * x * t + c;
//         const b01 = y * x * t + z * s;
//         const b02 = z * x * t - y * s;
//         const b10 = x * y * t - z * s;
//         const b11 = y * y * t + c;
//         const b12 = z * y * t + x * s;
//         const b20 = x * z * t + y * s;
//         const b21 = y * z * t - x * s;
//         const b22 = z * z * t + c;

//         // Perform rotation-specific matrix multiplication
//         out[0] = a00 * b00 + a10 * b01 + a20 * b02;
//         out[1] = a01 * b00 + a11 * b01 + a21 * b02;
//         out[2] = a02 * b00 + a12 * b01 + a22 * b02;
//         out[3] = a03 * b00 + a13 * b01 + a23 * b02;
//         out[4] = a00 * b10 + a10 * b11 + a20 * b12;
//         out[5] = a01 * b10 + a11 * b11 + a21 * b12;
//         out[6] = a02 * b10 + a12 * b11 + a22 * b12;
//         out[7] = a03 * b10 + a13 * b11 + a23 * b12;
//         out[8] = a00 * b20 + a10 * b21 + a20 * b22;
//         out[9] = a01 * b20 + a11 * b21 + a21 * b22;
//         out[10] = a02 * b20 + a12 * b21 + a22 * b22;
//         out[11] = a03 * b20 + a13 * b21 + a23 * b22;

//         if (a !== out) { // If the source and destination differ, copy the unchanged last row
//             out[12] = a[12];
//             out[13] = a[13];
//             out[14] = a[14];
//             out[15] = a[15];
//         }
//         return out;
//     }

//     /**
//      * Rotates a matrix by the given angle around the X axis not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to rotate
//      * @param {Number} rad the angle to rotate the matrix by
//      * @returns {mat4} out
//      */
//     public static rotateX(out: Float32Array, a: Float32Array, rad: number): Float32Array {
//         const s = Math.sin(rad);
//         const c = Math.cos(rad);
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];

//         if (a !== out) { // If the source and destination differ, copy the unchanged rows
//             out[0] = a[0];
//             out[1] = a[1];
//             out[2] = a[2];
//             out[3] = a[3];
//             out[12] = a[12];
//             out[13] = a[13];
//             out[14] = a[14];
//             out[15] = a[15];
//         }

//         // Perform axis-specific matrix multiplication
//         out[4] = a10 * c + a20 * s;
//         out[5] = a11 * c + a21 * s;
//         out[6] = a12 * c + a22 * s;
//         out[7] = a13 * c + a23 * s;
//         out[8] = a20 * c - a10 * s;
//         out[9] = a21 * c - a11 * s;
//         out[10] = a22 * c - a12 * s;
//         out[11] = a23 * c - a13 * s;
//         return out;
//     }


//     /**
//      * Rotates a matrix by the given angle around the Y axis not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to rotate
//      * @param {Number} rad the angle to rotate the matrix by
//      * @returns {mat4} out
//      */
//     public static rotateY(out: Float32Array, a: Float32Array, rad: number): Float32Array {
//         const s = Math.sin(rad);
//         const c = Math.cos(rad);
//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];

//         if (a !== out) { // If the source and destination differ, copy the unchanged rows
//             out[4] = a[4];
//             out[5] = a[5];
//             out[6] = a[6];
//             out[7] = a[7];
//             out[12] = a[12];
//             out[13] = a[13];
//             out[14] = a[14];
//             out[15] = a[15];
//         }

//         // Perform axis-specific matrix multiplication
//         out[0] = a00 * c - a20 * s;
//         out[1] = a01 * c - a21 * s;
//         out[2] = a02 * c - a22 * s;
//         out[3] = a03 * c - a23 * s;
//         out[8] = a00 * s + a20 * c;
//         out[9] = a01 * s + a21 * c;
//         out[10] = a02 * s + a22 * c;
//         out[11] = a03 * s + a23 * c;
//         return out;
//     }


//     /**
//      * Rotates a matrix by the given angle around the Z axis not using SIMD
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to rotate
//      * @param {Number} rad the angle to rotate the matrix by
//      * @returns {mat4} out
//      */
//     public static rotateZ(out: Float32Array, a: Float32Array, rad: number): Float32Array {
//         const s = Math.sin(rad);
//         const c = Math.cos(rad);
//         const a00 = a[0];
//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];

//         if (a !== out) { // If the source and destination differ, copy the unchanged last row
//             out[8] = a[8];
//             out[9] = a[9];
//             out[10] = a[10];
//             out[11] = a[11];
//             out[12] = a[12];
//             out[13] = a[13];
//             out[14] = a[14];
//             out[15] = a[15];
//         }

//         // Perform axis-specific matrix multiplication
//         out[0] = a00 * c + a10 * s;
//         out[1] = a01 * c + a11 * s;
//         out[2] = a02 * c + a12 * s;
//         out[3] = a03 * c + a13 * s;
//         out[4] = a10 * c - a00 * s;
//         out[5] = a11 * c - a01 * s;
//         out[6] = a12 * c - a02 * s;
//         out[7] = a13 * c - a03 * s;
//         return out;
//     }

//     /**
//      * Creates a matrix from a vector translation
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static translate(dest, dest, vec);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {vec3} v Translation vector
//      * @returns {mat4} out
//      */
//     public static fromTranslation(out: Float32Array, v: vec3): Float32Array {
//         out[0] = 1;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = 1;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = 1;
//         out[11] = 0;
//         out[12] = v[0];
//         out[13] = v[1];
//         out[14] = v[2];
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a matrix from a vector scaling
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static scale(dest, dest, vec);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {vec3} v Scaling vector
//      * @returns {mat4} out
//      */
//     public static fromScaling(out: Float32Array, v: vec3): Float32Array {
//         out[0] = v[0];
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = v[1];
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = v[2];
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a matrix from a given angle around a given axis
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static rotate(dest, dest, rad, axis);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {Number} rad the angle to rotate the matrix by
//      * @param {vec3} axis the axis to rotate around
//      * @returns {mat4} out
//      */
//     public static fromRotation(out: Float32Array, rad: number, axis: vec3): Float32Array {
//         let x = axis[0];
//         let y = axis[1];
//         let z = axis[2];
//         let len = Math.sqrt(x * x + y * y + z * z);

//         if (Math.abs(len) < glMatrix.EPSILON) {
//             return null;
//         }

//         len = 1 / len;
//         x *= len;
//         y *= len;
//         z *= len;

//         const s = Math.sin(rad);
//         const c = Math.cos(rad);
//         const t = 1 - c;

//         // Perform rotation-specific matrix multiplication
//         out[0] = x * x * t + c;
//         out[1] = y * x * t + z * s;
//         out[2] = z * x * t - y * s;
//         out[3] = 0;
//         out[4] = x * y * t - z * s;
//         out[5] = y * y * t + c;
//         out[6] = z * y * t + x * s;
//         out[7] = 0;
//         out[8] = x * z * t + y * s;
//         out[9] = y * z * t - x * s;
//         out[10] = z * z * t + c;
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a matrix from the given angle around the X axis
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static rotateX(dest, dest, rad);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {Number} rad the angle to rotate the matrix by
//      * @returns {mat4} out
//      */
//     public static fromXRotation(out: Float32Array, rad: number): Float32Array {
//         const s = Math.sin(rad);
//         const c = Math.cos(rad);

//         // Perform axis-specific matrix multiplication
//         out[0] = 1;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = c;
//         out[6] = s;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = -s;
//         out[10] = c;
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a matrix from the given angle around the Y axis
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static rotateY(dest, dest, rad);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {Number} rad the angle to rotate the matrix by
//      * @returns {mat4} out
//      */
//     public static fromYRotation(out: Float32Array, rad: number): Float32Array {
//         const s = Math.sin(rad);
//         const c = Math.cos(rad);

//         // Perform axis-specific matrix multiplication
//         out[0] = c;
//         out[1] = 0;
//         out[2] = -s;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = 1;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = s;
//         out[9] = 0;
//         out[10] = c;
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a matrix from the given angle around the Z axis
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static rotateZ(dest, dest, rad);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {Number} rad the angle to rotate the matrix by
//      * @returns {mat4} out
//      */
//     public static fromZRotation(out: Float32Array, rad: number): Float32Array {
//         const s = Math.sin(rad);
//         const c = Math.cos(rad);

//         // Perform axis-specific matrix multiplication
//         out[0] = c;
//         out[1] = s;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = -s;
//         out[5] = c;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = 1;
//         out[11] = 0;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Creates a matrix from a quaternion rotation and vector translation
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static translate(dest, vec);
//      *     var quatMat = mat4.create();
//      *     quat4.toMat4(quat, quatMat);
//      *     public static multiply(dest, quatMat);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {quat} q Rotation quaternion
//      * @param {vec3} v Translation vector
//      * @returns {mat4} out
//      */
//     public static fromRotationTranslation(out: Float32Array, q: quat, v: vec3): Float32Array {
//         // Quaternion math
//         const x = q[0];
//         const y = q[1];
//         const z = q[2];
//         const w = q[3];

//         const x2 = x + x;
//         const y2 = y + y;
//         const z2 = z + z;

//         const xx = x * x2;
//         const xy = x * y2;
//         const xz = x * z2;
//         const yy = y * y2;
//         const yz = y * z2;
//         const zz = z * z2;
//         const wx = w * x2;
//         const wy = w * y2;
//         const wz = w * z2;

//         out[0] = 1 - (yy + zz);
//         out[1] = xy + wz;
//         out[2] = xz - wy;
//         out[3] = 0;
//         out[4] = xy - wz;
//         out[5] = 1 - (xx + zz);
//         out[6] = yz + wx;
//         out[7] = 0;
//         out[8] = xz + wy;
//         out[9] = yz - wx;
//         out[10] = 1 - (xx + yy);
//         out[11] = 0;
//         out[12] = v[0];
//         out[13] = v[1];
//         out[14] = v[2];
//         out[15] = 1;

//         return out;
//     }

//     /**
//      * Returns the translation vector component of a `ation
//      *  matrix. If a matrix is built with fromRotationTranslation,
//      *  the returned vector will be the same as the translation vector
//      *  originally supplied.
//      * @param  {vec3} out Vector to receive translation component
//      * @param  {mat4} mat Matrix to be decomposed (input)
//      * @return {vec3} out
//      */
//     public static getTranslation(out: vec3, mat: Float32Array): vec3 {
//         out[0] = mat[12];
//         out[1] = mat[13];
//         out[2] = mat[14];

//         return out;
//     }

//     /**
//      * Returns the scaling factor component of a transformation
//      *  matrix. If a matrix is built with fromRotationTranslationScale
//      *  with a normalized Quaternion paramter, the returned vector will be
//      *  the same as the scaling vector
//      *  originally supplied.
//      * @param  {vec3} out Vector to receive scaling factor component
//      * @param  {mat4} mat Matrix to be decomposed (input)
//      * @return {vec3} out
//      */
//     public static getScaling(out: vec3, mat: Float32Array): vec3 {
//         const m11 = mat[0];
//         const m12 = mat[1];
//         const m13 = mat[2];
//         const m21 = mat[4];
//         const m22 = mat[5];
//         const m23 = mat[6];
//         const m31 = mat[8];
//         const m32 = mat[9];
//         const m33 = mat[10];

//         out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
//         out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
//         out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

//         return out;
//     }

//     /**
//      * Returns a quaternion representing the rotational component
//      *  of a transformation matrix. If a matrix is built with
//      *  fromRotationTranslation, the returned quaternion will be the
//      *  same as the quaternion originally supplied.
//      * @param {quat} out Quaternion to receive the rotation component
//      * @param {mat4} mat Matrix to be decomposed (input)
//      * @return {quat} out
//      */
//     public static getRotation(out: quat, mat: Float32Array): quat {
//         // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
//         const trace = mat[0] + mat[5] + mat[10];
//         let S = 0;

//         if (trace > 0) {
//             S = Math.sqrt(trace + 1.0) * 2;
//             out[3] = 0.25 * S;
//             out[0] = (mat[6] - mat[9]) / S;
//             out[1] = (mat[8] - mat[2]) / S;
//             out[2] = (mat[1] - mat[4]) / S;
//         } else if ((mat[0] > mat[5]) && (mat[0] > mat[10])) {
//             S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
//             out[3] = (mat[6] - mat[9]) / S;
//             out[0] = 0.25 * S;
//             out[1] = (mat[1] + mat[4]) / S;
//             out[2] = (mat[8] + mat[2]) / S;
//         } else if (mat[5] > mat[10]) {
//             S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
//             out[3] = (mat[8] - mat[2]) / S;
//             out[0] = (mat[1] + mat[4]) / S;
//             out[1] = 0.25 * S;
//             out[2] = (mat[6] + mat[9]) / S;
//         } else {
//             S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
//             out[3] = (mat[1] - mat[4]) / S;
//             out[0] = (mat[8] + mat[2]) / S;
//             out[1] = (mat[6] + mat[9]) / S;
//             out[2] = 0.25 * S;
//         }

//         return out;
//     }

//     /**
//      * Creates a matrix from a quaternion rotation, vector translation and vector scale
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static translate(dest, vec);
//      *     var quatMat = mat4.create();
//      *     quat4.toMat4(quat, quatMat);
//      *     public static multiply(dest, quatMat);
//      *     public static scale(dest, scale)
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {quat4} q Rotation quaternion
//      * @param {vec3} v Translation vector
//      * @param {vec3} s Scaling vector
//      * @returns {mat4} out
//      */
//     public static fromRotationTranslationScale(out: Float32Array, q: quat, v: vec3, s: vec3): Float32Array {
//         // Quaternion math
//         const x = q[0];
//         const y = q[1];
//         const z = q[2];
//         const w = q[3];
//         const x2 = x + x;
//         const y2 = y + y;
//         const z2 = z + z;

//         const xx = x * x2;
//         const xy = x * y2;
//         const xz = x * z2;
//         const yy = y * y2;
//         const yz = y * z2;
//         const zz = z * z2;
//         const wx = w * x2;
//         const wy = w * y2;
//         const wz = w * z2;
//         const sx = s[0];
//         const sy = s[1];
//         const sz = s[2];

//         out[0] = (1 - (yy + zz)) * sx;
//         out[1] = (xy + wz) * sx;
//         out[2] = (xz - wy) * sx;
//         out[3] = 0;
//         out[4] = (xy - wz) * sy;
//         out[5] = (1 - (xx + zz)) * sy;
//         out[6] = (yz + wx) * sy;
//         out[7] = 0;
//         out[8] = (xz + wy) * sz;
//         out[9] = (yz - wx) * sz;
//         out[10] = (1 - (xx + yy)) * sz;
//         out[11] = 0;
//         out[12] = v[0];
//         out[13] = v[1];
//         out[14] = v[2];
//         out[15] = 1;

//         return out;
//     }

//     /**
//      * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
//      * This is equivalent to (but much faster than):
//      *
//      *     public static identity(dest);
//      *     public static translate(dest, vec);
//      *     public static translate(dest, origin);
//      *     var quatMat = mat4.create();
//      *     quat4.toMat4(quat, quatMat);
//      *     public static multiply(dest, quatMat);
//      *     public static scale(dest, scale)
//      *     public static translate(dest, negativeOrigin);
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {quat4} q Rotation quaternion
//      * @param {vec3} v Translation vector
//      * @param {vec3} s Scaling vector
//      * @param {vec3} o The origin vector around which to scale and rotate
//      * @returns {mat4} out
//      */
//     public static fromRotationTranslationScaleOrigin(out: Float32Array, q: quat, v: vec3, s: vec3, o: vec3): Float32Array {
//         // Quaternion math
//         const x = q[0];
//         const y = q[1];
//         const z = q[2];
//         const w = q[3];

//         const x2 = x + x;
//         const y2 = y + y;
//         const z2 = z + z;

//         const xx = x * x2;
//         const xy = x * y2;
//         const xz = x * z2;
//         const yy = y * y2;
//         const yz = y * z2;
//         const zz = z * z2;
//         const wx = w * x2;
//         const wy = w * y2;
//         const wz = w * z2;

//         const sx = s[0];
//         const sy = s[1];
//         const sz = s[2];

//         const ox = o[0];
//         const oy = o[1];
//         const oz = o[2];

//         out[0] = (1 - (yy + zz)) * sx;
//         out[1] = (xy + wz) * sx;
//         out[2] = (xz - wy) * sx;
//         out[3] = 0;
//         out[4] = (xy - wz) * sy;
//         out[5] = (1 - (xx + zz)) * sy;
//         out[6] = (yz + wx) * sy;
//         out[7] = 0;
//         out[8] = (xz + wy) * sz;
//         out[9] = (yz - wx) * sz;
//         out[10] = (1 - (xx + yy)) * sz;
//         out[11] = 0;
//         out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
//         out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
//         out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
//         out[15] = 1;

//         return out;
//     }

//     /**
//      * Calculates a 4x4 matrix from the given quaternion
//      *
//      * @param {mat4} out mat4 receiving operation result
//      * @param {quat} q Quaternion to create matrix from
//      *
//      * @returns {mat4} out
//      */
//     public static fromQuat(out: Float32Array, q: quat): Float32Array {
//         const x = q[0];
//         const y = q[1];
//         const z = q[2];
//         const w = q[3];

//         const x2 = x + x;
//         const y2 = y + y;
//         const z2 = z + z;

//         const xx = x * x2;
//         const yx = y * x2;
//         const yy = y * y2;
//         const zx = z * x2;
//         const zy = z * y2;
//         const zz = z * z2;
//         const wx = w * x2;
//         const wy = w * y2;
//         const wz = w * z2;

//         out[0] = 1 - yy - zz;
//         out[1] = yx + wz;
//         out[2] = zx - wy;
//         out[3] = 0;

//         out[4] = yx - wz;
//         out[5] = 1 - xx - zz;
//         out[6] = zy + wx;
//         out[7] = 0;

//         out[8] = zx + wy;
//         out[9] = zy - wx;
//         out[10] = 1 - xx - yy;
//         out[11] = 0;

//         out[12] = 0;
//         out[13] = 0;
//         out[14] = 0;
//         out[15] = 1;

//         return out;
//     }

//     /**
//      * Generates a frustum matrix with the given bounds
//      *
//      * @param {mat4} out mat4 frustum matrix will be written into
//      * @param {Number} left Left bound of the frustum
//      * @param {Number} right Right bound of the frustum
//      * @param {Number} bottom Bottom bound of the frustum
//      * @param {Number} top Top bound of the frustum
//      * @param {Number} near Near bound of the frustum
//      * @param {Number} far Far bound of the frustum
//      * @returns {mat4} out
//      */
//     public static frustum(out: Float32Array, left: number, right: number, bottom: number, top: number, near: number, far: number): Float32Array {
//         const rl = 1 / (right - left);
//         const tb = 1 / (top - bottom);
//         const nf = 1 / (near - far);
//         out[0] = (near * 2) * rl;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = (near * 2) * tb;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = (right + left) * rl;
//         out[9] = (top + bottom) * tb;
//         out[10] = (far + near) * nf;
//         out[11] = -1;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = (far * near * 2) * nf;
//         out[15] = 0;
//         return out;
//     }

//     /**
//      * Generates a perspective projection matrix with the given bounds
//      *
//      * @param {mat4} out mat4 frustum matrix will be written into
//      * @param {number} fovy Vertical field of view in radians
//      * @param {number} aspect Aspect ratio. typically viewport width/height
//      * @param {number} near Near bound of the frustum
//      * @param {number} far Far bound of the frustum
//      * @returns {mat4} out
//      */
//     public static perspective(out: Float32Array, fovy: number, aspect: number, near: number, far: number): Float32Array {
//         const f = 1.0 / Math.tan(fovy / 2);
//         const nf = 1 / (near - far);
//         out[0] = f / aspect;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = f;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = (far + near) * nf;
//         out[11] = -1;
//         out[12] = 0;
//         out[13] = 0;
//         out[14] = (2 * far * near) * nf;
//         out[15] = 0;
//         return out;
//     }

//     /**
//      * Generates a perspective projection matrix with the given field of view.
//      * This is primarily useful for generating projection matrices to be used
//      * with the still experiemental WebVR API.
//      *
//      * @param {mat4} out mat4 frustum matrix will be written into
//      * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
//      * @param {number} near Near bound of the frustum
//      * @param {number} far Far bound of the frustum
//      * @returns {mat4} out
//      */
//     public static perspectiveFromFieldOfView(out: Float32Array, fov: {
//         upDegrees: number, downDegrees: number, leftDegrees: number,
//         rightDegrees: number
//     }, near: number, far: number): Float32Array {
//         const upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
//         const downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
//         const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
//         const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
//         const xScale = 2.0 / (leftTan + rightTan);
//         const yScale = 2.0 / (upTan + downTan);

//         out[0] = xScale;
//         out[1] = 0.0;
//         out[2] = 0.0;
//         out[3] = 0.0;
//         out[4] = 0.0;
//         out[5] = yScale;
//         out[6] = 0.0;
//         out[7] = 0.0;
//         out[8] = -((leftTan - rightTan) * xScale * 0.5);
//         out[9] = ((upTan - downTan) * yScale * 0.5);
//         out[10] = far / (near - far);
//         out[11] = -1.0;
//         out[12] = 0.0;
//         out[13] = 0.0;
//         out[14] = (far * near) / (near - far);
//         out[15] = 0.0;
//         return out;
//     }

//     /**
//      * Generates a orthogonal projection matrix with the given bounds
//      *
//      * @param {mat4} out mat4 frustum matrix will be written into
//      * @param {number} left Left bound of the frustum
//      * @param {number} right Right bound of the frustum
//      * @param {number} bottom Bottom bound of the frustum
//      * @param {number} top Top bound of the frustum
//      * @param {number} near Near bound of the frustum
//      * @param {number} far Far bound of the frustum
//      * @returns {mat4} out
//      */
//     public static ortho(out: Float32Array, left: number, right: number, bottom: number, top: number, near: number, far: number): Float32Array {
//         const lr = 1 / (left - right);
//         const bt = 1 / (bottom - top);
//         const nf = 1 / (near - far);
//         out[0] = -2 * lr;
//         out[1] = 0;
//         out[2] = 0;
//         out[3] = 0;
//         out[4] = 0;
//         out[5] = -2 * bt;
//         out[6] = 0;
//         out[7] = 0;
//         out[8] = 0;
//         out[9] = 0;
//         out[10] = 2 * nf;
//         out[11] = 0;
//         out[12] = (left + right) * lr;
//         out[13] = (top + bottom) * bt;
//         out[14] = (far + near) * nf;
//         out[15] = 1;
//         return out;
//     }

//     /**
//      * Generates a look-at matrix with the given eye position, focal point, and up axis
//      *
//      * @param {mat4} out mat4 frustum matrix will be written into
//      * @param {vec3} eye Position of the viewer
//      * @param {vec3} center Point the viewer is looking at
//      * @param {vec3} up vec3 pointing up
//      * @returns {mat4} out
//      */
//     public static lookAt(out: Float32Array, eye: vec3 | number[], center: vec3 | number[], up: vec3 | number[]): Float32Array {
//         let x0;
//         let x1;
//         let x2;
//         let y0;
//         let y1;
//         let y2;
//         let z0;
//         let z1;
//         let z2;
//         let len;
//         const eyex = eye[0];
//         const eyey = eye[1];
//         const eyez = eye[2];
//         const upx = up[0];
//         const upy = up[1];
//         const upz = up[2];
//         const centerx = center[0];
//         const centery = center[1];
//         const centerz = center[2];

//         if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
//             Math.abs(eyey - centery) < glMatrix.EPSILON &&
//             Math.abs(eyez - centerz) < glMatrix.EPSILON) {
//             return mat4.identity(out);
//         }

//         z0 = eyex - centerx;
//         z1 = eyey - centery;
//         z2 = eyez - centerz;

//         len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
//         z0 *= len;
//         z1 *= len;
//         z2 *= len;

//         x0 = upy * z2 - upz * z1;
//         x1 = upz * z0 - upx * z2;
//         x2 = upx * z1 - upy * z0;
//         len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
//         if (!len) {
//             x0 = 0;
//             x1 = 0;
//             x2 = 0;
//         } else {
//             len = 1 / len;
//             x0 *= len;
//             x1 *= len;
//             x2 *= len;
//         }

//         y0 = z1 * x2 - z2 * x1;
//         y1 = z2 * x0 - z0 * x2;
//         y2 = z0 * x1 - z1 * x0;

//         len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
//         if (!len) {
//             y0 = 0;
//             y1 = 0;
//             y2 = 0;
//         } else {
//             len = 1 / len;
//             y0 *= len;
//             y1 *= len;
//             y2 *= len;
//         }

//         out[0] = x0;
//         out[1] = y0;
//         out[2] = z0;
//         out[3] = 0;
//         out[4] = x1;
//         out[5] = y1;
//         out[6] = z1;
//         out[7] = 0;
//         out[8] = x2;
//         out[9] = y2;
//         out[10] = z2;
//         out[11] = 0;
//         out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
//         out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
//         out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
//         out[15] = 1;

//         return out;
//     }

//     /**
//      * Returns Frobenius norm of a mat4
//      *
//      * @param {mat4} a the matrix to calculate Frobenius norm of
//      * @returns {Number} Frobenius norm
//      */
//     public static frob(a: Float32Array): number {
//         return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2)
//             + Math.pow(a[2], 2) + Math.pow(a[3], 2)
//             + Math.pow(a[4], 2) + Math.pow(a[5], 2)
//             + Math.pow(a[6], 2) + Math.pow(a[7], 2)
//             + Math.pow(a[8], 2) + Math.pow(a[9], 2)
//             + Math.pow(a[10], 2) + Math.pow(a[11], 2)
//             + Math.pow(a[12], 2) + Math.pow(a[13], 2)
//             + Math.pow(a[14], 2) + Math.pow(a[15], 2)));
//     }

//     /**
//      * Adds two mat4's
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the first operand
//      * @param {mat4} b the second operand
//      * @returns {mat4} out
//      */
//     public static add(out: Float32Array, a: Float32Array, b: Float32Array): Float32Array {
//         out[0] = a[0] + b[0];
//         out[1] = a[1] + b[1];
//         out[2] = a[2] + b[2];
//         out[3] = a[3] + b[3];
//         out[4] = a[4] + b[4];
//         out[5] = a[5] + b[5];
//         out[6] = a[6] + b[6];
//         out[7] = a[7] + b[7];
//         out[8] = a[8] + b[8];
//         out[9] = a[9] + b[9];
//         out[10] = a[10] + b[10];
//         out[11] = a[11] + b[11];
//         out[12] = a[12] + b[12];
//         out[13] = a[13] + b[13];
//         out[14] = a[14] + b[14];
//         out[15] = a[15] + b[15];
//         return out;
//     }

//     /**
//      * Subtracts matrix b from matrix a
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the first operand
//      * @param {mat4} b the second operand
//      * @returns {mat4} out
//      */
//     public static subtract(out: Float32Array, a: Float32Array, b: Float32Array): Float32Array {
//         out[0] = a[0] - b[0];
//         out[1] = a[1] - b[1];
//         out[2] = a[2] - b[2];
//         out[3] = a[3] - b[3];
//         out[4] = a[4] - b[4];
//         out[5] = a[5] - b[5];
//         out[6] = a[6] - b[6];
//         out[7] = a[7] - b[7];
//         out[8] = a[8] - b[8];
//         out[9] = a[9] - b[9];
//         out[10] = a[10] - b[10];
//         out[11] = a[11] - b[11];
//         out[12] = a[12] - b[12];
//         out[13] = a[13] - b[13];
//         out[14] = a[14] - b[14];
//         out[15] = a[15] - b[15];
//         return out;
//     }

//     /**
//      * Alias for {@link mat4.subtract}
//      * @function
//      */
//     public static sub = mat4.subtract;

//     /**
//      * Multiply each element of the matrix by a scalar.
//      *
//      * @param {mat4} out the receiving matrix
//      * @param {mat4} a the matrix to scale
//      * @param {Number} b amount to scale the matrix's elements by
//      * @returns {mat4} out
//      */
//     public static multiplyScalar(out: Float32Array, a: Float32Array, b: number): Float32Array {
//         out[0] = a[0] * b;
//         out[1] = a[1] * b;
//         out[2] = a[2] * b;
//         out[3] = a[3] * b;
//         out[4] = a[4] * b;
//         out[5] = a[5] * b;
//         out[6] = a[6] * b;
//         out[7] = a[7] * b;
//         out[8] = a[8] * b;
//         out[9] = a[9] * b;
//         out[10] = a[10] * b;
//         out[11] = a[11] * b;
//         out[12] = a[12] * b;
//         out[13] = a[13] * b;
//         out[14] = a[14] * b;
//         out[15] = a[15] * b;
//         return out;
//     }

//     /**
//      * Adds two mat4's after multiplying each element of the second operand by a scalar value.
//      *
//      * @param {mat4} out the receiving vector
//      * @param {mat4} a the first operand
//      * @param {mat4} b the second operand
//      * @param {Number} scale the amount to scale b's elements by before adding
//      * @returns {mat4} out
//      */
//     public static multiplyScalarAndAdd(out: Float32Array, a: Float32Array, b: Float32Array, scale: number): Float32Array {
//         out[0] = a[0] + (b[0] * scale);
//         out[1] = a[1] + (b[1] * scale);
//         out[2] = a[2] + (b[2] * scale);
//         out[3] = a[3] + (b[3] * scale);
//         out[4] = a[4] + (b[4] * scale);
//         out[5] = a[5] + (b[5] * scale);
//         out[6] = a[6] + (b[6] * scale);
//         out[7] = a[7] + (b[7] * scale);
//         out[8] = a[8] + (b[8] * scale);
//         out[9] = a[9] + (b[9] * scale);
//         out[10] = a[10] + (b[10] * scale);
//         out[11] = a[11] + (b[11] * scale);
//         out[12] = a[12] + (b[12] * scale);
//         out[13] = a[13] + (b[13] * scale);
//         out[14] = a[14] + (b[14] * scale);
//         out[15] = a[15] + (b[15] * scale);
//         return out;
//     }

//     /**
//      * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
//      *
//      * @param {mat4} a The first matrix.
//      * @param {mat4} b The second matrix.
//      * @returns {Boolean} True if the matrices are equal, false otherwise.
//      */
//     public static exactEquals(a: Float32Array, b: Float32Array): boolean {
//         return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
//             a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
//             a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
//             a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
//     }

//     /**
//      * Returns whether or not the matrices have approximately the same elements in the same position.
//      *
//      * @param {mat4} a The first matrix.
//      * @param {mat4} b The second matrix.
//      * @returns {Boolean} True if the matrices are equal, false otherwise.
//      */
//     public static equals(a: Float32Array, b: Float32Array): boolean {
//         const a0 = a[0];
//         const a1 = a[1];
//         const a2 = a[2];
//         const a3 = a[3];
//         const a4 = a[4];
//         const a5 = a[5];
//         const a6 = a[6];
//         const a7 = a[7];
//         const a8 = a[8];
//         const a9 = a[9];
//         const a10 = a[10];
//         const a11 = a[11];
//         const a12 = a[12];
//         const a13 = a[13];
//         const a14 = a[14];
//         const a15 = a[15];

//         const b0 = b[0];
//         const b1 = b[1];
//         const b2 = b[2];
//         const b3 = b[3];
//         const b4 = b[4];
//         const b5 = b[5];
//         const b6 = b[6];
//         const b7 = b[7];
//         const b8 = b[8];
//         const b9 = b[9];
//         const b10 = b[10];
//         const b11 = b[11];
//         const b12 = b[12];
//         const b13 = b[13];
//         const b14 = b[14];
//         const b15 = b[15];

//         return (Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
//             Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
//             Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
//             Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
//             Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
//             Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
//             Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
//             Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
//             Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
//             Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
//             Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
//             Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
//             Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
//             Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
//             Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
//             Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15)));
//     }


//     public static rotateTemporary(a, b, c, d) {
//         let e = c[0];
//         let g = c[1];
//         c = c[2];
//         let f = Math.sqrt(e * e + g * g + c * c);
//         if (!f) {
//             return null;
//         }
//         if (f !== 1) {
//             f = 1 / f;
//             e *= f;
//             g *= f;
//             c *= f;
//         }
//         const h = Math.sin(b);
//         const i = Math.cos(b);
//         const j = 1 - i;
//         b = a[0];
//         f = a[1];
//         const k = a[2];
//         const l = a[3];
//         const o = a[4];
//         const m = a[5];
//         const n = a[6];
//         const p = a[7];
//         const r = a[8];
//         const s = a[9];
//         const A = a[10];
//         const B = a[11];
//         const t = e * e * j + i;
//         const u = g * e * j + c * h;
//         const v = c * e * j - g * h;
//         const w = e * g * j - c * h;
//         const x = g * g * j + i;
//         const y = c * g * j + e * h;
//         const z = e * c * j + g * h;
//         e = g * c * j - e * h;
//         g = c * c * j + i;
//         if (d) {
//             if (a !== d) {
//                 d[12] = a[12];
//                 d[13] = a[13];
//                 d[14] = a[14];
//                 d[15] = a[15];
//             }
//         } else {
//             d = a;
//         }
//         d[0] = b * t + o * u + r * v;
//         d[1] = f * t + m * u + s * v;
//         d[2] = k * t + n * u + A * v;
//         d[3] = l * t + p * u + B * v;
//         d[4] = b * w + o * x + r * y;
//         d[5] = f * w + m * x + s * y;
//         d[6] = k * w + n * x + A * y;
//         d[7] = l * w + p * x + B * y;
//         d[8] = b * z + o * e + r * g;
//         d[9] = f * z + m * e + s * g;
//         d[10] = k * z + n * e + A * g;
//         d[11] = l * z + p * e + B * g;
//         return d;
//     }

//     public static multiplyTemporary(a, b, c) {
//         c || (c = a);
//         const d = a[0];
//         const e = a[1];
//         const g = a[2];
//         const f = a[3];
//         const h = a[4];
//         const i = a[5];
//         const j = a[6];
//         const k = a[7];
//         const l = a[8];
//         const o = a[9];
//         const m = a[10];
//         const n = a[11];
//         const p = a[12];
//         const r = a[13];
//         const s = a[14];
//         a = a[15];
//         const A = b[0];
//         const B = b[1];
//         const t = b[2];
//         const u = b[3];
//         const v = b[4];
//         const w = b[5];
//         const x = b[6];
//         const y = b[7];
//         const z = b[8];
//         const C = b[9];
//         const D = b[10];
//         const E = b[11];
//         const q = b[12];
//         const F = b[13];
//         const G = b[14];
//         b = b[15];
//         c[0] = A * d + B * h + t * l + u * p;
//         c[1] = A * e + B * i + t * o + u * r;
//         c[2] = A * g + B * j + t * m + u * s;
//         c[3] = A * f + B * k + t * n + u * a;
//         c[4] = v * d + w * h + x * l + y * p;
//         c[5] = v * e + w * i + x * o + y * r;
//         c[6] = v * g + w * j + x * m + y * s;
//         c[7] = v * f + w * k + x * n + y * a;
//         c[8] = z * d + C * h + D * l + E * p;
//         c[9] = z * e + C * i + D * o + E * r;
//         c[10] = z * g + C * j + D * m + E * s;
//         c[11] = z * f + C * k + D * n + E * a;
//         c[12] = q * d + F * h + G * l + b * p;
//         c[13] = q * e + F * i + G * o + b * r;
//         c[14] = q * g + F * j + G * m + b * s;
//         c[15] = q * f + F * k + G * n + b * a;
//         return c;
//     }

//     public static transformPoint(n, t, i) {
//         n[0] = t[0] * i[0] + t[4] * i[1] + t[8] * i[2] + t[12];
//         n[1] = t[1] * i[0] + t[5] * i[1] + t[9] * i[2] + t[13];
//         n[2] = t[2] * i[0] + t[6] * i[1] + t[10] * i[2] + t[14];

//         return n;
//     }

//     public static inverseMat4(mat, dest) {
//         if (!dest) {
//             dest = mat;
//         }

//         // Cache the matrix values (makes for huge speed increases!)
//         const a00 = mat[0];

//         const a01 = mat[1];
//         const a02 = mat[2];
//         const a03 = mat[3];
//         const a10 = mat[4];
//         const a11 = mat[5];
//         const a12 = mat[6];
//         const a13 = mat[7];
//         const a20 = mat[8];
//         const a21 = mat[9];
//         const a22 = mat[10];
//         const a23 = mat[11];
//         const a30 = mat[12];
//         const a31 = mat[13];
//         const a32 = mat[14];
//         const a33 = mat[15];
//         const b00 = a00 * a11 - a01 * a10;
//         const b01 = a00 * a12 - a02 * a10;
//         const b02 = a00 * a13 - a03 * a10;
//         const b03 = a01 * a12 - a02 * a11;
//         const b04 = a01 * a13 - a03 * a11;
//         const b05 = a02 * a13 - a03 * a12;
//         const b06 = a20 * a31 - a21 * a30;
//         const b07 = a20 * a32 - a22 * a30;
//         const b08 = a20 * a33 - a23 * a30;
//         const b09 = a21 * a32 - a22 * a31;
//         const b10 = a21 * a33 - a23 * a31;
//         const b11 = a22 * a33 - a23 * a32;

//         // Calculate the determinant (inlined to avoid double-caching)
//         const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

//         dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
//         dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
//         dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
//         dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
//         dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
//         dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
//         dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
//         dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
//         dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
//         dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
//         dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
//         dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
//         dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
//         dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
//         dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
//         dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

//         return dest;
//     }

//     public static mulMat4(a, b, dest) {
//         if (!dest) {
//             dest = a;
//         }

//         // Cache the matrix values (makes for huge speed increases!)
//         const a00 = a[0];

//         const a01 = a[1];
//         const a02 = a[2];
//         const a03 = a[3];
//         const a10 = a[4];
//         const a11 = a[5];
//         const a12 = a[6];
//         const a13 = a[7];
//         const a20 = a[8];
//         const a21 = a[9];
//         const a22 = a[10];
//         const a23 = a[11];
//         const a30 = a[12];
//         const a31 = a[13];
//         const a32 = a[14];
//         const a33 = a[15];
//         const b00 = b[0];
//         const b01 = b[1];
//         const b02 = b[2];
//         const b03 = b[3];
//         const b10 = b[4];
//         const b11 = b[5];
//         const b12 = b[6];
//         const b13 = b[7];
//         const b20 = b[8];
//         const b21 = b[9];
//         const b22 = b[10];
//         const b23 = b[11];
//         const b30 = b[12];
//         const b31 = b[13];
//         const b32 = b[14];
//         const b33 = b[15];

//         dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
//         dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
//         dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
//         dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
//         dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
//         dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
//         dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
//         dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
//         dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
//         dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
//         dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
//         dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
//         dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
//         dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
//         dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
//         dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

//         return dest;
//     }
// }
